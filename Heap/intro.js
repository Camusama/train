// 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。

// 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：

// 同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

// 该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

// 大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]

// 小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]

// ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

// 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

// a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

// 　　b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

// 　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
// O(nlogn)
let arr = [4, 6, 8, 5, 9]
let sortHeap = function (arr) {
  //第一个非叶子节点
  let s = Math.floor(arr.length / 2) - 1
  //从第一个非叶子结点从下至上，从右至左调整结构
  for (i = s; i >= 0; i--) {
    adjustHeap(arr, i, arr.length)
  }

  //2.调整堆结构+交换堆顶元素与末尾元素
  for (let j = arr.length - 1; j > 0; j--) {
    // console.log(1, arr)
    ;[arr[0], arr[j]] = [arr[j], arr[0]]
    // console.log(2, arr, j)
    adjustHeap(arr, 0, j) //重新对堆进行调整
  }
}
let adjustHeap = function (arr, i, len) {
  let cur = arr[i]
  //取当前节点，迭代到当前节点的左子节点
  //i永远指向父，k指向子
  for (let k = 2 * i + 1; k < len; k = 2 * k + 1) {
    //比左右哪个大，k去指向它
    //这里k+1<len无比关键，防止访问到已经排除在len外的
    if (k + 1 < len && arr[k] < arr[k + 1]) {
      k = k + 1
    }
    //如果大于父，赋值给父
    if (arr[k] > cur) {
      arr[i] = arr[k]
      //k指向被赋值的点(新父），然后迭代这个点的子 k = 2 * k + 1
      i = k
    } else {
      break
    }
  }
  arr[i] = cur
}
moudule.exports = {
  adjustHeap,
}
console.log(sortHeap(arr), arr)
